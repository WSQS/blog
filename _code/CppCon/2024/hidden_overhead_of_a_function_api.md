---
title: Hidden Overhead of a Function API by Oleksandr Bacherikov
date: 2025-03-25
tags:
  - Cpp
  - CppCon
---

## Introduction

ref: C++ Now 2023 Tony Van Eerd Value Oriented Programming

also C++ Now 2021 and cppcon 2017

> People are not writing enough functions

When people finally start writing more functions, we'd prefer to get only the well designed ones!

Well designed function api can have a large impact on performance.

Compare performance by compare the number of instructions generated by a compiler.

ref: Accelerate large-scale applications with BOLT

Disclaimer: only for non-inlined functions.

- System V ABI
- Microsoft ABI

C++ Core Guidelines seem like a good candidate

ref: C++ Core Guidelines

## Return Value

> For "out" output values, prefer return values to output parameters.

Reason: A return value is self-documenting, whereas a & could be either in-out or out-only and is liable to be misused.

### Returning std::unique_ptr

Output value is shorter.

Call site.

> Always initialize an object

Reason: Avoid used-before-set errors and their associated undefined behavior.

Any C++ compiler checks that every execution path in a function ends with a return statement. We just need to return by value.

> Use a `unique_ptr<T>` to transfer ownership where a pointer is needed.

Reason: Using unique_ptr is the cheapest way to pass a pointer safely.

unique_ptr add some overhead

memory is about 3 times slower than register.

### Wrapper over int

Class return the memory.

ref: Itanimum C++ ABI

Non-trivial Return Value: callee constructs the return value into this address.

For trivial class it returns register. And also size limit.

> If you can avoid defining default operations, do.

reason: It's simplest and gives the cleanest semantics. It's knows as the rule of zero.

Don't use std::pair and especially `std::tuple`. Named struct is better for both readability and performance.

For `std::unique_ptr`, using `[[always_inline]]` and wrapper the raw pointer.
