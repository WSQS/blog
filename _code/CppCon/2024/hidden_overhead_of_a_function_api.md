---
title: Hidden Overhead of a Function API by Oleksandr Bacherikov
date: 2025-03-25
url: https://www.bilibili.com/video/BV14YyfYhE3C/?p=17
tags:
  - Cpp
  - CppCon
---

## Introduction

ref: C++ Now 2023 Tony Van Eerd Value Oriented Programming

also C++ Now 2021 and cppcon 2017

> People are not writing enough functions

When people finally start writing more functions, we'd prefer to get only the well designed ones!

Well designed function api can have a large impact on performance.

Compare performance by compare the number of instructions generated by a compiler.

ref: Accelerate large-scale applications with BOLT

Disclaimer: only for non-inlined functions.

- System V ABI
- Microsoft ABI

C++ Core Guidelines seem like a good candidate

ref: C++ Core Guidelines

## Return Value

> For "out" output values, prefer return values to output parameters.

Reason: A return value is self-documenting, whereas a & could be either in-out or out-only and is liable to be misused.

### Returning std::unique_ptr

Output value is shorter.

Call site.

> Always initialize an object

Reason: Avoid used-before-set errors and their associated undefined behavior.

Any C++ compiler checks that every execution path in a function ends with a return statement. We just need to return by value.

> Use a `unique_ptr<T>` to transfer ownership where a pointer is needed.

Reason: Using unique_ptr is the cheapest way to pass a pointer safely.

unique_ptr add some overhead

memory is about 3 times slower than register.

### Wrapper over int

Class return the memory.

ref: Itanimum C++ ABI

Non-trivial Return Value: callee constructs the return value into this address.

For trivial class it returns register. And also size limit.

> If you can avoid defining default operations, do.

Reason: It's simplest and gives the cleanest semantics. It's knows as the rule of zero.

Don't use std::pair and especially `std::tuple`. Named struct is better for both readability and performance.

For `std::unique_ptr`, using `[[always_inline]]` and wrapper the raw pointer.

### Return Value Optimization

ref: C++ reference: copy elision

A prvalue(pure rvalue) will constructed directly into the storage of its final destination.

ref: cppcon 2024 can you RVO?

`std::optional` will turns prvalue into rvalue.

It also affect `std::variant` `std::vector` `std::map`

ref: Superconstructing super elider solution

ref:CppNow 2024 An Adventure Modern Library

ref: Meeting C++ 2023 Prog C++ Ivan Cukic

solution: [lazy](https://github.com/AlCash07/ACTL/blob/main/include/actl/functional/lazy.hpp)

Negative-overhead abstraction!

### Valid use case for output parameters

`std::ranges::transform`

`std::ranges::sort`

`ac::out` and `ac::inout`

## Parameter passing

> For in parameters, pass cheaply-copied types by value and others by reference to const.

Reason: Both let the caller know that a function will not modify the argument, and both allow initialization by rvalues.

For reference, need to put variable in stack and clean up stack.

### Perfect forwarding

Perfect forwarding is not perfect.

Forwarding reference is still a reference, so it prevents passing in register.

ref: cppcon 2019 There are no Zero-cost abstractions Chandler Carruth

For non trivial type, passing by reference is more efficient.

### `std::span`

> Use a span<T> ir a span_p<T> to designate a half-open sequence

Reason: Informal/non-explicit ranges are a source of errors.

On Most platforms `std::span` has no overhead.

`std::mdspan` has overhead on more platforms. Cause `std::mdspan` is too large to get into registers.

`std::span` is not free.

For empty class has size and alignment 1.

`this` Parameters is the implicit first parameter. This isn't efficient if the class is small enough to be passed by value.

C++ 23 introduces static `operator()` and `[]`

## Multiple parameters

### Chain of function calls

Order of parameters is fixed in every ABI.

ref: Not leacing Performance on the jump table Eduardo Madrid in cppcon

> Do not pass an array as a single pointer.
> Keep the number of function arguments low.

Reason: Having many arguments opens opportunities for confusion. Passing lots of arguments is often costly compared to alternatives.

Triple product: all int or vector 3

ref: Keep an eye out for buffer security checks

For all int there is a lot of moving.

And stack pointer is heavily used.

Number of Register is limited.

## Conclusion

- Compilers do unexpected thing to your code, because they have to follow all the specification.
- Compiler Explorer is you friend.
- C++ Core Guidelines are pretty reasonable from performance point of view.

Guidelines:

- Return by value
- Pass trivial types by value, oters by reference
- Follow the rule of 0, or support trivial copy
- Make APIs consistent
- Understand abstraction cost on your target platform
