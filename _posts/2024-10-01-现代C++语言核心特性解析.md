---
title: 现代C++语言核心特性解析
date: 2024-10-01
---

- [新基础类型（C++11～C++20）](#新基础类型c11c20)
  - [整数类型long long](#整数类型long-long)
  - [新字符类型char16\_t和char32\_t](#新字符类型char16_t和char32_t)
  - [char8\_t字符类型](#char8_t字符类型)
- [内联和嵌套命名空间（C++11～C++20）](#内联和嵌套命名空间c11c20)
- [auto占位符（C++11～C++17）](#auto占位符c11c17)
  - [auto推导规则](#auto推导规则)
  - [什么时候使用auto](#什么时候使用auto)
- [decltype说明符（C++11～C++17）](#decltype说明符c11c17)
  - [decltype推导规则](#decltype推导规则)
- [函数返回类型后置（C++11）](#函数返回类型后置c11)
- [右值引用（C++11 C++17 C++20）](#右值引用c11-c17-c20)
  - [值类别](#值类别)
  - [将左值转换为右值](#将左值转换为右值)
  - [万能引用](#万能引用)
- [lambda表达式（C++11～C++20）](#lambda表达式c11c20)
  - [捕获列表](#捕获列表)
  - [lambda表达式的实现原理](#lambda表达式的实现原理)
  - [广义捕获](#广义捕获)
- [非静态数据成员默认初始化（C++11 C++20）](#非静态数据成员默认初始化c11-c20)
- [列表初始化（C++11 C++20）](#列表初始化c11-c20)
- [默认和删除函数（C++11）](#默认和删除函数c11)
- [非受限联合类型（C++11）](#非受限联合类型c11)
- [委托构造函数（C++11）](#委托构造函数c11)
- [继承构造函数（C++11）](#继承构造函数c11)
- [强枚举类型（C++11 C++17 C++20）](#强枚举类型c11-c17-c20)
- [扩展的聚合类型（C++17 C++20）](#扩展的聚合类型c17-c20)
- [override和final说明符（C++11）](#override和final说明符c11)
- [基于范围的for循环（C++11 C++17 C++20）](#基于范围的for循环c11-c17-c20)
- [支持初始化语句的if和switch（C++17）](#支持初始化语句的if和switchc17)
- [static\_assert声明](#static_assert声明)
- [结构化绑定（C++17 C++20）](#结构化绑定c17-c20)
- [noexcept关键字（C++11 C++17 C++20）](#noexcept关键字c11-c17-c20)
- [类型别名和别名模板（C++11 C++14）](#类型别名和别名模板c11-c14)
- [指针字面量nullptr（C++11）](#指针字面量nullptrc11)
- [三向比较（C++20）](#三向比较c20)
- [线程局部存储（C++11）](#线程局部存储c11)
- [扩展的inline说明符（C++17）](#扩展的inline说明符c17)
- [常量表达式（C++11～C++20）](#常量表达式c11c20)
- [确定的表达式求值顺序（C++17）](#确定的表达式求值顺序c17)
- [字面量优化（C++11～C++17）](#字面量优化c11c17)
- [alignas和alignof（C++11 C++17）](#alignas和alignofc11-c17)
- [属性说明符和标准属性（C++11～C++20）](#属性说明符和标准属性c11c20)
- [新增预处理器和宏（C++17 C++20）](#新增预处理器和宏c17-c20)
- [协程（C++20）](#协程c20)
- [基础特性的其他优化（C++11～C++20）](#基础特性的其他优化c11c20)
- [可变参数模板（C++11 C++17 C++20）](#可变参数模板c11-c17-c20)

## 新基础类型（C++11～C++20）

### 整数类型long long

在C++中应该尽量少使用宏，用模板取而代之是明智的选择。使用模板可以得到指定类型的最大最小值。

```cpp
std::numeric_limits<long long>::max()
```

### 新字符类型char16_t和char32_t

C++11标准还为3种编码提供了新前缀用于声明3种编码字符和字符串的字面量，它们分别是UTF-8的前缀u8、UTF-16的前缀u和UTF-32的前缀U。wchar_t的前缀是L。

字符类型转换，包含在cuchar库当中。

|   名称   |      作用      |
| :------: | :------------: |
| mbrtoc16 | 多字节转UTF-16 |
| c16rtomb | UTF-16转多字节 |
| mbrtoc32 | 多字节转UTF-32 |
| c32rtomb | UTF-32转多字节 |

通过以下方式可以在字符串中使用新字符类型。

```cpp
using u16string = basic_string;
using u32string = basic_string;
using wstring = basic_string;
```

### char8_t字符类型

c++20引入，用于解决char类型处理UTF-8的问题。

## 内联和嵌套命名空间（C++11～C++20）

内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了。主要用于无缝升级库代码。

嵌套命名空间可以简化命名空间中类的声明。C++20引入了嵌套形式的内联命名空间。

## auto占位符（C++11～C++17）

- 当用一个auto关键字声明多个变量的时候，编译器遵从由左往右的推导规则，以最左边的表达式推断auto的具体类型。
- 当使用条件表达式初始化auto声明的变量时，编译器总是使用表达能力更强的类型。
- 虽然C++11标准已经支持在声明成员变量时初始化，但是auto却无法在这种情况下声明非静态成员变量。
- 按照C++20之前的标准，无法在函数形参列表中使用auto声明形参（注意，在C++14中，auto可以为lambda表达式声明形参）

### auto推导规则

- 如果auto声明的变量是按值初始化，则推导出的类型会忽略const和volatile限定符。
- 使用auto声明变量初始化时，目标对象如果是引用，则引用属性会被忽略。
- 使用auto和万能引用声明变量时，对于左值会将auto推导为引用类型。(涉及到引用折叠)
- 使用auto声明变量，如果目标对象是一个数组或者函数，则auto会被推导为对应的指针类型
- 当auto关键字与列表初始化组合时。若直接使用列表初始化，列表中必须为单元素，否则无法编译，auto类型被推导为单元素的类型。若用等号加列表初始化，列表中可以包含单个或者多个元素，auto类型被推导为`std::initializer_list<T>`，其中T是元素类型。(列表中元素类型需要相同)

### 什么时候使用auto

- 当一眼就能看出声明变量的初始化类型的时候可以使用auto。
- 对于复杂的类型，例如lambda表达式、bind等直接使用auto。

把auto写到lambda表达式的形参中，这样就得到了一个泛型的lambda表达式

c++17允许auto作为非类型模板形参占位符。

## decltype说明符（C++11～C++17）

### decltype推导规则

- 如果e是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。
- 如果e是一个函数调用或者仿函数调用，那么decltype(e)推断出的类型是其返回值的类型。
- 如果e是一个类型为T的左值，则decltype(e)是T&。
- 如果e是一个类型为T的将亡值，则decltype(e)是T&&。
- 除去以上情况，则decltype(e)是T。

decltype(auto)是使用decltype的推导规则来推导auto，但是它必须单独声明，不能结合指针、引用和cv限定符。

c++17也允许decltype(auto)作为类型模板形参占位符

## 函数返回类型后置（C++11）

auto作为占位符，在->声明返回类型。

传统函数声明语法无法将函数指针类型作为返回类型直接使用，需要使用typedef将函数指针类型创建别名，再使用别名作为返回类型。使用后置返回类型则不需要这样。

可以使用decltype推导函数模板返回类型。

`std::declval`函数模板声明

## 右值引用（C++11 C++17 C++20）

左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。能取到内存地址的值为左值，否则为右值。通常字面量都是一个右值，除字符串字面量以外。

非常量左值的引用对象很单纯，它们必须是一个左值。对常量左值引用的特性显得更加有趣，它除了能引用左值，还能够引用右值。

右值引用是一种引用右值且只能引用右值的方法。右值引用的特点之一是可以延长右值的生命周期，并且减少对象复制，提升程序性能。

移动语义，它可以帮助我们将临时对象的内存移动到左值对象中，以避免内存数据的复制。

复制构造函数和移动构造函数：复制构造函数使用常量左值引用作为参数，移动构造函数使用右值引用作为参数，通过转移实参对象的数据以达成构造对象的目的。对于右值编译器会优先选择使用移动构造函数去构造目标对象。当移动构造函数不存在的时候才会退而求其次地使用复制构造函数。移动构造函数和移动赋值运算符等价。

移动语义的风险：异常会导致无法预测的结果，可以使用noexcept说明符限制该函数。

### 值类别

c++11将表达式区分为左值（lvalue）、纯右值（prvalue）和将亡值（xvalue）。表达式首先被分为了泛左值（glvalue）和右值（rvalue），其中泛左值被进一步划分为左值和将亡值，右值又被划分为将亡值和纯右值。

泛左值是具名对象。纯右值是能够用于初始化对象和位域，或者能够计算运算符操作数的值的表达式。

从本质上说产生将亡值的途径有两种，第一种是使用类型转换将泛左值转换为该类型的右值引用。第二种在C++17标准中引入，我们称它为临时量实质化，指的是纯右值转换到临时对象的过程，在C++17标准之前临时变量是纯右值，只有转换为右值引用的类型才是将亡值。

### 将左值转换为右值

在C++11标准中可以在不创建临时值的情况下显式地将左值通过static_cast转换为将亡值。值得注意的是，由于转换的并不是右值，因此它依然有着和转换之前相同的生命周期和内存地址。这可以让左值使用移动语义。

无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用。在C++11的标准库中还提供了一个函数模板std::move帮助我们将左值转换为右值。

### 万能引用

所谓的万能引用是因为发生了类型推导。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。

引用折叠规定了在不同的引用类型互相作用的情况下应该如何推导出最终类型，当模板类型为左值引用时，只有实际类型为右值引用，推导得到的才会是右值引用，否则就是左值引用。

万能引用最典型的用途被称为完美转发。std::forward函数模板可以帮助完成转发。

c++针对局部变量和右值引用的隐式移动操作进行了优化。

## lambda表达式（C++11～C++20）

语法定义：`[ captures ] ( params ) specifiers exception -> ret { body }`

- `[ captures ]` —— 捕获列表，它可以捕获当前函数作用域的零个或多个变量，变量之间用逗号分隔。
- ( params ) —— 可选参数列表.
- specifiers —— 可选限定符，C++11中可以用mutable，它允许我们在lambda表达式函数体内改变按值捕获的变量，或者调用非const的成员函数。
- exception —— 可选异常说明符，我们可以使用noexcept来指明lambda是否会抛出异常。
- ret —— 可选返回值类型，不同于普通函数，lambda表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（void类型），可以忽略包括->在内的整个部分。
- { body } —— lambda表达式的函数体。

### 捕获列表

被捕获的变量必须是自动存储类型，及非静态的局部变量。捕获变量可以是捕获值或是捕获引用。捕获值的变量默认无法被修改，除非添加mutable，而lambda表达式中的捕获值的变量类似静态局部变量，会记忆修改，并且不会和外部作用域的值同步。

### lambda表达式的实现原理

lambda表达式类似函数对象。在编译器由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，我们称它为闭包。

无状态的lambda表达式可以隐式转换为函数指针。

### 广义捕获

简单捕获：

- `[this]` —— 捕获this指针，捕获this指针可以让我们使用this类型的成员变量和函数。
- `[=]` —— 捕获lambda表达式定义作用域的全部变量的值，包括this。
- `[&]` —— 捕获lambda表达式定义作用域的全部变量的引用，包括this。

初始化捕获支持捕获表达式结果以及自定义捕获变量名。

c++17添加constexpr关键字，以及捕获this指针，在捕获列表中直接使用this纸箱对象的成员。

c++20加入`[=, this]`，以区分`[=, *this]`

c++20中添加模板对lambda的支持`[]<typename T>(T t) {}`。

C++20标准允许了无状态lambda表达式类型的构造和赋值。

## 非静态数据成员默认初始化（C++11 C++20）

C++11标准提出了新的初始化方法，即在声明非静态数据成员的同时直接对其使用=或者{}初始化。在初始化的优先级上有这样的规则，初始化列表对数据成员的初始化总是优先于声明时默认初始化。

在C++20中我们可以对数据成员的位域进行默认初始化。

## 列表初始化（C++11 C++20）

C++11标准引入了列表初始化，它使用大括号{}对变量进行初始化，和传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化。它支持隐式调用多参数的构造函数。也可以使用列表初始化对标准容器进行初始化。

std::initializer_list简单地说就是一个支持begin、end以及size成员函数的类模板。只需要添加一个以std::initializer_list为形参的构造函数就可以支持列表初始化。

注意事项：

- 隐式缩窄转换报错
- 列表初始化的优先级问题：std::initializer_ list为参数的构造函数优先

C++20标准中引入了指定初始化的特性，允许指定初始化数据成员的名称，从而使代码意图更加明确。

## 默认和删除函数（C++11）

编译器会为类添加默认的构造函数。像这样有特殊待遇的成员函数一共有6个：

- 默认构造函数。
- 析构函数。
- 复制构造函数。
- 复制赋值运算符函数。
- 移动构造函数（C++11新增）。
- 移动赋值运算符函数（C++11新增）。

问题：

- 声明任何构造函数都会抑制默认构造函数的添加。
- 一旦用自定义构造函数代替默认构造函数，类就将转变为非平凡类型。

c++11引入=default和=delete表示显式默认和显示删除。=default可以添加到类内部函数声明，也可以添加到类外部。它可以让我们在不修改头文件里函数声明的情况下，改变函数内部的行为。=delete必须添加在类内部的函数声明中。显式删除特定类的new运算符可以阻止该类在堆上动态创建对象。

## 非受限联合类型（C++11）

过去的C++标准规定，联合类型的成员变量的类型不能是一个非平凡类型，也就是说它的成员类型不能有自定义构造函数。

>当面对一个可能被滥用的功能时，语言的设计者往往有两条路可走，一是为了语言的安全性禁止此功能，另外则是为了语言的能力和灵活性允许这个功能，C++的设计者一般会采用后者。但是联合类型的设计却与这一理念背道而驰。这种限制完全没有必要，去除它可以让联合类型更加实用。

在C++11中如果有联合类型中存在非平凡类型，那么这个联合类型的特殊成员函数将被隐式删除，也就是说我们必须自己至少提供联合类型的构造和析构函数。比较推荐让联合类型的构造和析构函数为空，也就是什么也不做，并且将其成员的构造和析构函数放在需要使用联合类型的地方。可以使用placement new的技巧进行初始化，在使用完成后手动调用对象的析构函数。如果开发环境支持C++17标准，则大部分情况下我们可以使用std::variant来代替联合体。

## 委托构造函数（C++11）

一个类有多个不同的构造函数会包含重复的代码，并且使得代码的重复变得困难。若把数据成员的初始化放到一个函数中，会因为对成员及逆行两次操作导致额外的性能开销。某个类型的一个构造函数可以委托同类型的另一个构造函数对对象进行初始化。委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完之后，再执行委托构造函数的主体。

注意：

- 每个构造函数都可以委托另一个构造函数为代理。特殊构造函数也能成为委托构造函数。
- 递归循环委托会导致未定义的行为，例如栈内存用尽。建议使用委托构造函数时，通常只指定一个代理构造函数即可，其他的构造函数都委托到这个代理构造函数，尽量不要形成链式委托，避免出现循环递归委托。
- 如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化。
- 委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体。
- 如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数。

委托模板构造函数是指一个构造函数将控制权委托到同类型的一个模板构造函数，简单地说，就是代理构造函数是一个函数模板。这样做的意义在于泛化了构造函数，减少冗余的代码的产生。

## 继承构造函数（C++11）

当父类中存在大量的构造函数时，子类中也需要定义同样多的构造函数来转发构造参数。可以使用using关键字将父类的函数引入子类，c++11允许使用using关键字将父类的构造函数引入到子类中，`using Base::Base`这可以让编译器自己生成转发到基类的构造函数。

注意

- 派生类是隐式继承基类的构造函数，所以只有在程序中使用了这些构造函数，编译器才会为派生类生成继承构造函数的代码。
- 派生类不会继承基类的默认构造函数和复制构造函数。执行派生类默认构造函数之前一定会先执行基类的构造函数。同样的，在执行复制构造函数之前也一定会先执行基类的复制构造函数。
- 继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类构造函数的派生类，编译器依然会为其自动生成默认构造函数的代码。
- 在派生类中声明签名相同的构造函数会禁止继承相应的构造函数。
- 派生类继承多个签名相同的构造函数会导致编译失败。
- 继承构造函数的基类构造函数不能为私有。

## 强枚举类型（C++11 C++17 C++20）

大多数情况下，我们说C++是一门类型安全的强类型语言，但是枚举类型在一定程度上却是一个例外。

- 枚举类型可以隐式转换为整型
- 枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域。

将枚举类型变量封装成类私有数据成员，保证无法被外界访问。访问枚举类型的数据成员必须通过对应的常量静态对象。

- 无法指定枚举类型的底层类型。因此，不同的编译器对于相同枚举类型可能会有不同的底层类型，甚至有无符号也会不同。

如果代码中有需要表达枚举语义的地方，还是应该使用枚举类型。

C++11添加强枚举类型，在enum之后加上class关键字。

- 枚举标识符属于强枚举类型的作用域，在访问时必须加上枚举类型名，否则会编译失败。
- 枚举标识符不会隐式转换为整型。
- 能指定强枚举类型的底层类型，底层类型默认为int类型。使用:符号指定。
- 强枚举类型不允许匿名。

C++17对有底层类型的枚举类型对象可以直接使用列表初始化。

C++17的枚举类型是一个完美的新整数类型。std::byte就是这样实现的。

C++20可是使用using打开强枚举类型的命名空间:`using enum EnumName;`，也可以只引入特定的枚举标识符:`using EnumName:Enum;`

## 扩展的聚合类型（C++17 C++20）

C++17规定从基类公开且非虚继承的类也可能是一个聚合。

派生类是聚合类型的条件

- 没有用户提供的构造函数。但是可以声明默认构造函数，在C++20中禁止。
- 没有私有和受保护的非静态数据成员。
- 没有虚函数。
- 必须是公开的基类，不能是私有或者受保护的基类。
- 必须是非虚继承。

`<type_traits>`中有`is_aggregate`来判定是否是聚合类型。

可以简化对聚合类型的初始化，只需要删除派生类中用户提供的构造函数，就可以直接初始化(直接使用聚合大括号初始化即可)。总是假设基类是一种在所有数据成员之前声明的特殊成员，如果派生类存在多个基类，那么其初始化的顺序与继承的顺序相同。

C++20规定聚合类型对象的初始化可以用小括号列表来完成，其最终结果与大括号列表相同。

## override和final说明符（C++11）

- override(重写):派生类覆盖了积累的虚函数，需要有相同的函数签名和返回类型。
- overload(重载):函数名相同，函数签名不同。
- overwrite(隐藏):当派生类中出现和基类同名的函数，并且签名不同时，基类函数会被隐藏，若签名相同，但并非是虚函数时，也会被隐藏，若要使用，需要用using关键字将其引入派生类。

C++11引入override说明符来明确这个虚函数需要覆盖基类的虚函数。编译器会在无法override时给出错误提示。

C++11引入final说明符来阻止派生类继承基类的虚函数，final说明符也能声明类，使得类无法被继承。

override和final都不是保留的关键字，它们可以作为标识符。

## 基于范围的for循环（C++11 C++17 C++20）

标准库中提供了std::for_each函数，来基于开始和结束的迭代器遍历执行函数。

C++11标准引入了基于范围的for循环特性，要求：

- 对象类型定义了begin和end成员函数。
- 定义了以对象类型为参数的begin和end普通函数。

C++17标准使得begin和end函数不必返回相同类型。

陷阱：对泛左值进行基于范围的for循环会引发未定义的行为。for循环中的for采用的是右值引用，无法拓展左值引用的生命周期。

C++20标准增加了对初始化语句的支持。`for (T thing = foo(); auto & x :thing.items()) {}`

实现一个支持基于范围的for循环的类，要求：

- 该类型必须有一组和其类型相关的begin和end函数，它们可以是类型的成员函数，也可以是独立函数。
- begin和end函数需要返回一组类似迭代器的对象，并且这组对象必须支持operator *、operator !=和operator ++运算符函数。operator ++应该是一个前缀版本，它需要通过声明一个不带形参的operator ++运算符函数来完成。

可以实现独立版本的begin和end函数来在不修改第三方代码的情况下支持基于范围的for循环。

## 支持初始化语句的if和switch（C++17）

C++17 允许在执行调节语句之前先执行一个初始化语句:`if (init; condition) {}`，变量拥有和整个if结构一样长的生命周期。else if 之中也支持初始化语句。可以利用这种方式对整个if结构加锁。switch也支持初始化语句。

## static_assert声明

断言不能代替程序中的错误检查，它只应该出现在需要表达式返回true的位置，相反，如果表达式中涉及外部输入，则不应该依赖断言，例如客户输入、服务端返回等。

需要静态断言在编译阶段对模板实参进行约束。

C++11标准规定，使用static_assert需要传入两个实参：常量表达式和诊断消息字符串。

C++17标准中运行单参数的static_assert。

当断言表达式时常量表达式时，应该优先使用static_assert静态断言。

## 结构化绑定（C++17 C++20）

C++11引入了元组，允许函数有多个返回值，使用`std::make_tuple()`和`std::tie()`实现。还有`std::ignore`可以使用。

C++17引入了结构化绑定，将一个或多个名称绑定到初始化对象中的一个或者多个子对象上，相当于给初始化对象的子对象起了别名。结构化绑定能够直接绑定到结构体上，也可以作为for循环中初始化时直接进行。

原理：在结构化绑定中编译器会根据限定符生成一个等号右边对象的匿名副本，而绑定的对象正是这个副本而非原对象本身。

别名的内存地址不同，也不能通过修改其值去修改其原始值。

使用结构化绑定无法忽略对象的子对象或者元素。

结构化绑定可以作用于原生数组、结构体和类对象、元组和类元组的对象。绑定到原生数组需要小心数组退化为指针。结构体和类的数据成员必须是公有的，又或者上下文允许访问私有数据成员，必须是在同一个类或者基类当中，并且不能存在匿名联合体。只要满足条件，类都可以作为绑定的目标。

## noexcept关键字（C++11 C++17 C++20）

移动构造函数中包含着一个严重的异常陷阱。移动语义会破坏原始对象，因此移动构造函数中途发生异常就会导致原始对象不可用。因此引入noexcept关键字。用于说明函数是否会抛出异常，编译器可以根据声明优化代码，若是抛出异常，则会被调用std::terminate去结束程序的生命周期。noexcept还接受一个返回布尔值的常量表达式。noexcept还可以作为运算符。

对于移动构造函数可以先判断目标类型的构造函数是否有可能抛出异常，如果没有排除异常的可能，那么函数可以进行移动操作，否则将使用传统的复制操作。

使用noexcept和throw()声明的函数对于noexcept运算符来说是一样的。

C++11标准规定以下函数默认带有noexcept声明:

- 默认构造函数、默认复制构造函数、默认赋值构造函数、默认移动构造函数和默认移动赋值函数。
- 类型的析构函数以及delete运算符默认嗲有noexcept声明。

C++17将异常规范引入了类型系统。

## 类型别名和别名模板（C++11 C++14）

可以使用typedef 为较长的类型名定义一个别名。

C++11引入using关键字。`using identifier = type-id`

别名模板可以在模板形参比较多的时候简化模板形参。

```cpp
template < template-parameter-list >
using identifier = type-id;
```

## 指针字面量nullptr（C++11）

C++11之前NULL本质上就是0，这会带来二义性的错误。

C++11引入nullptr，它能够隐式转换为各种指针类型，但无法隐式转换到非指针类型。虽然nullptr可以和0进行比较，但是不能隐式转换为整形。nullptr的类型为std::nullptr_t。

## 三向比较（C++20）

三向比较就是在形如lhs <=> rhs的表达式中，两个比较的操作数lhs和rhs通过<=>比较可能产生3种结果，该结果可以和0比较，小于0、等于0或者大于0分别对应lhs < rhs、lhs == rhs和lhs > rhs。

三向比较的返回类型可能会有多种：

- std::strong_ordering会返回三种比较结果，less、equal和strong。strong意味着可替换性，equal的值在任何情况下都可以相互替换。
- std::weak_ordering会返回三种比较结果，less、equivalent和greater。weak意味着不可替换性。
- std::partial_ordering会返回四种比较结果，less、equivalent、greater和unordered。unordered表示进行比较的两个操作数没有关系。

默认情况下自定义类型是不存在三项比较运算符函数的，需要用户显式默认声明`=default`。当std::weak_ordering和std::strong_ordering同时出现在基类和数据成员的类型中时，结果会是std::strong_ordering。类似的，std::partial_ordering会得到保留。std::common_comparison_category可以用于判断三向判断的结果。这三个类型只能与0相比较。

std::rel_ops可以在提供==和<运算符的情况下自动生成!=、>、<=和>=。C++20规定如果用户为自定义类型声明了三项比较运算符，那么编译器会自动生成<、>、<=、>=。三向比较也能够通过运算符<和==来自动生成。

## 线程局部存储（C++11）

之前操作系统支持系统线程局部存储。Windows:TlsAlloc，Linux:pthreads。

C++11引入thread_local说明符，与static或extern结合声明内部或外部链接。可以解决多线程中错误码被覆盖的问题，从C++11之后，errno被修改为线程局部存储变量。

线程局部存储只是定义了对象的生命周期，没有定义可访问性。在同一个线程中，一个线程局部存储对象只会初始化一次，即使在某个函数中被多次调用。

## 扩展的inline说明符（C++17）

非常量静态成员变量需要将声明和定义分开进行，并且保证静态成员变量的定义有且只有一份。

C++17允许使用inline说明符内联定义静态变量。

inline的语义：inline说明符可以应用于变量以及函数。声明为inline的变量与函数具有相同的语义：它们一方面可以在多个翻译单元中定义，另一方面又必须在每个使用它们的翻译单元中定义，并且程序的行为就像是同一个变量。

## 常量表达式（C++11～C++20）

const存在无法确定的问题，C++11引入constexpr定义常量表达式。

constexpr值要在在编译期完成计算，必须被常量表达式初始化。

constexpr是一个加强版的const，它不仅要求常量表达式是常量，而且要求是一个编译阶段就能够确定其值的常量。

constexpr函数要求其返回值可以在编译阶段就计算出来。约束：

- 函数必须返回一个值，所以返回类型不能是void。
- 函数体必须只有一条语句：return expr，并且expr必须也是一个常量表达式。可以使用三元表达式。可以考虑使用递归。
- 函数使用之前必须有定义
- 函数必须用constexpr声明

自定义类型的构造函数也可以添加constexpr说明符，必须确保析构函数是平凡的。要求：

- 自定义类型中不能有用户自定义的析构函数
- 析构函数不能是虚函数
- 基类和成员的析构函数必须都是平凡的

C++14放宽了对constexpr的限制。

C++17 lambda表达式在允许的情况下隐式声明为constexpr。

if constexpr可以根据编译时确定的值省略代码。

C++20允许constexpr虚函数，允许在constexpr中继续宁try-catch。允许更改联合类型的有效成员。

consteval声明立即函数，要求必须在编译期执行计算。

constinit用于具有静态存储持续时间的变量声明。

std::is_constant_evaluated 可以检查当前表达式是否是一个常量求值环境。

## 确定的表达式求值顺序（C++17）

C++17之前没有确定的表达式求值顺序。

C++17开始函数表达式一定会在参数之前求值，但是参数之间的求值顺序仍然没有确定。因此在函数的参数列表中，尽可能少地修改共享的对象，否则会很难确认实参地真实值。

对于后缀表达式和移位操作符，表达式求值总是从左往右。赋值表达式求值总是从右向左。new 表达式中，内存分配总是优先于构造函数参数的求值。

## 字面量优化（C++11～C++17）

C++11引入`std::hexfloat`和`std::defaultfloat`，可以将浮点数输入输出的格式进行修改。

添加原生字符串字面量`R"delimiter(raw_characters)delimiter"`，delimiter长度至多16个字，可以改变编译器对原生字符串字面量范围的判定。R可以扩展成u8R、uR、UR、LR。

重载字面量运算符函数`return_type operator "" identifier(params)`，可以将整数、浮点数、字符和字符串转化为特定的对象。标识符应该尽量以下划线开始。有多种形参列表可以选择。

C++17允许使用十六进制浮点字面量

C++14定义二进制整数字面量，引入单引号作为整数分隔符，对于十进制、八进制、十六进制和二进制都有效。

## alignas和alignof（C++11 C++17）

正确的数据对齐可以有效的提升性能。

C++11引入alignof获取类型的对齐字节长度，alignas可以改变类型的默认对齐字节长度。

alignof是针对类型的。所有标量类型都适应std::max_align_t的对齐字节长度。

alignas接受类型或常量表达式，其计算结果必须是一个2的幂值。它既可以用于结构体，也可以用于结构体的成员变量。如果修改结构体成员的对齐字节长度，那么结构体本身的对齐字节长度也会发生变化，结构体类型的字节成都总是需要大于或等于其成员变量类型的对齐字节长度。

`std::alignment_of<>`可以获取类型的对齐字节长度。

`std::aligned_storage<>`可以分配一块指定对齐字节长度和大小的内存。

`std::aligned_union`可以接受`std::size_t`作为分配内存的大小以及不定数量的类型，并选择其中对齐字节长度最大的作为分配内存的对齐字节长度。

`std::align`可以返回一个缓冲区中最近的符合指定对齐字节长度的指针。

C++17中new运算发也拥有了根据对齐字节长度分配对象的能力。这并不需要额外的代码介入。

## 属性说明符和标准属性（C++11～C++20）

GCC的属性语法:`_attribute__((attribute-list))`，它可以用于结构体、类、联合类型、枚举类型、变量或者函数。

MSVC属性语法为`__declspec(attribute-list)`。

C++11引入了标准的属性说明符：`[[attr]]`。普遍的规则是，属性说明符总是声明位于其之前的对象，而在整个声明之前的属性则会声明语句中所有声明的对象。

属性说明符包含命名空间，C++17允许使用using关键字在属性说明符中打开命名空间以简化代码：`[[ using attribute-namespace : attribute-list ]]`，另外，C++17规定编译器应该忽略任何无法识别的属性。

`[[noreturn]]`声明函数不会返回。

`[[carries_dependency]]`声明允许跨函数传递内存依赖项。

`[[deprecated("str")]]`C++14引入，被使用时编译器会报警。

`[[fallthrough]]`C++17对switch报警的规避。

`[[nodiscard]]`C++17引入函数返回值不应该被舍弃，可以用在类和枚举类型上，当函数返回值为该类型时有效，对引用无效。C++20允许添加一个字符串。

`[[maybe_unused]]`C++17引入说明实体可能不会被使用。

`[[likely]]`和`[[unlikely]]`C++20引入用于说明该属性的执行路径是否需要进行优化。

`[[no_unique]]`用于说明数据成员不需要与其他非静态成员使用不同的地址。可以节省无状态的类的内存空间。

## 新增预处理器和宏（C++17 C++20）

C++17引入`__has_include`来判断某个头文件是否能够被包含进来。

C++20添加测试功能特性的宏，用于测试当前编译环境对各种功能特性的支持程度。

属性测试宏`__has_cpp_attribute`可以只是编译环境是否支持某种属性。标准属性将被展开为改属性添加到标准的年份和月份，而厂商特有的属性将被展开为一个非零的值。

语言功能特性测试宏会展开为该特性添加到标准时的年份和月份。

标准库功能特性测试宏。

C++11引入可变参数宏`__VA_ARGS__`。C++20引入`__VA_OPT__`令可变参数宏更易于在参数为空的情况下使用。

## 协程（C++20）

携程是一种可以被挂起和恢复的函数，它提供了一种创建异步代码的方法。

`co_wait`挂起点的标志。`co_return`恢复协程。

异步执行会打乱输出。

`co_yield`挂起程序并在下次运行时从挂起点恢复运行。

具有以上三个关键字种任意一个的函数就是协程，main函数不能为协程。

应该尽量将协程和future和generator一起使用。协程并不会自动执行异步操作。

// TODO:具体实现未看

## 基础特性的其他优化（C++11～C++20）

C++11支持显示自定义类型转换运算符，但是会有意想不到的结果。单参数的构造函数也会造成类型的隐式转换，可以通过添加前缀`explicit`来避免这个问题。对于布尔转换，在某些期待上下文为bool类型的语境中，可以隐式进行转换，即使已经被声明为显示。

`std::launder()`在C++17引入。C++标准规定：如果新的对象在已被某个对象占用的内存上进行构建，那么原始对象的指针、引用以及对象名都会自动转向新的对象，除非对象是一个常量类型或对象中有常量数据成员或者引用类型。std::launder可以防止编译器追踪到数据的来源以阻止编译器对数据的优化。

返回值优化。但实际上的返回值优化是很容易失效的。传引用和移动语义都可以在一定程度上取代返回值优化。

C++20：按值进行默认比较。支持new表达式推导数组长度。

// TODO:一些C++20小的新特性未看

## 可变参数模板（C++11 C++17 C++20）

C++11引入可变参数模板之后，std::bind和std::tuple终于支持接受任意多个模板形参。

`class ...Args`是模板形参包。`Args ...args`是函数形参包。`args...`是形参包展开，即解包。

类模板中，模板形参包必须是模板形参列表的最后一个形参，函数模板则不需要。还有非类型模板形参。

包展开：有点抽象

// TODO:有需要再看
