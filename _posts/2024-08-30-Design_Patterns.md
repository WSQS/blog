---
title: Design Patterns Lesson Note
date: 2024-08-30
---

[课程](https://www.bilibili.com/video/BV1Yr4y157Ci/)的笔记

- [设计模式的原因](#设计模式的原因)
- [面向对象设计原则](#面向对象设计原则)
- [重构关键技法](#重构关键技法)
- [设计模式分类](#设计模式分类)
- [组件协作模式](#组件协作模式)
  - [Template Method](#template-method)
  - [Strategy](#strategy)
  - [Observer](#observer)
- [单一职责模式](#单一职责模式)
  - [Decorator](#decorator)
  - [Bridge](#bridge)
- [对象创建模式](#对象创建模式)
  - [Factory Method](#factory-method)
  - [Abstract Factory Method](#abstract-factory-method)
  - [Prototype](#prototype)
  - [Builder](#builder)
- [对象性能模式](#对象性能模式)
  - [Singleton](#singleton)
  - [Flyweight](#flyweight)
- [接口隔离模式](#接口隔离模式)
  - [Facade](#facade)
  - [Proxy](#proxy)
  - [Adapter](#adapter)
  - [Mediator](#mediator)
- [状态变化模式](#状态变化模式)
  - [State](#state)
  - [Memento](#memento)
- [数据结构模式](#数据结构模式)
  - [Composite](#composite)
  - [Iterator](#iterator)
  - [Chain of Responsibility](#chain-of-responsibility)
- [行为变化模式](#行为变化模式)
  - [Command](#command)
  - [Visitor](#visitor)
- [领域规则模式](#领域规则模式)
  - [Interpreter](#interpreter)
- [总结](#总结)
- [参考文献](#参考文献)

## 设计模式的原因

应对复杂性和变化的两种方式：分解与抽象

目标：复用

复用是指二进制级别的复用性

接口标准化

## 面向对象设计原则

- 依赖倒置原则（DIP）
  - 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）
  - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该抽象（稳定）
- 开放封闭原则（OCP）
  - 对拓展开放，对更改封闭
  - 类模块应该是可扩展的，但是不可修改
- 单一职责原则（SRP）
  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任
- Liskov 替换原则（LSP）
  - 子类必须能够替换它们的基类（IS-A）
  - 继承表达类型抽象
- 接口隔离原则
  - 不应该强迫客户程序依赖它们不用的方法
  - 接口应该小而完备
- 优先使用对象组合，而不是类继承
  - 类继承通常为“白箱复用”，对象组合通常为“黑箱”复用
  - 继承在某种程度上破坏了封装性，子类父类耦合度高
  - 而对象组合则只要求被组合的对象具有良好顶的接口，耦合度低
- 封装变化点
  - 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合
- 针对接口编程，而不是针对实现编程
  - 不将变量类型声明为特定的具体类，而是声明为某个接口
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  - 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案

## 重构关键技法

- 重构获得设计模式
  - 好的面向对象设计是指可以满足“应对变化，提高复用”的设计模式
  - 设计模式的要点是寻找变化点，然后再变化点处应用设计模式，从而来更好的应对需求的变化，假定有变化有不变
  - 设计模式的应用不宜先入为主

- 重构关机技法
  - 静态->动态
  - 早绑定->晚绑定
  - 继承->组合
  - 编译时依赖->运行时依赖
  - 紧耦合->松耦合

## 设计模式分类

- 从目的来看
  - 创建型(Creational)模式：对象创建
  - 结构型(Structural)模式：需求变化对结构的冲击
  - 行为型(Behavioral)模式：交互过程中责任的划分
- 从范围（实现手段）来看
  - 类模式：类与子类的静态关系
  - 对象模式：对象间的动态关系
- 从封装变化角度对模式分类
  - 组件协作
  - 单一职责
  - 对象创建
  - 对象性能
  - 接口隔离
  - 状态变化
  - 数据结构
  - 行为变化
  - 领域问题

## 组件协作模式

- 要点
  - 框架与应用程序的划分
  - 组件协作模式通过晚期绑定来实现框架与应用程序之间的松耦合，是两者之间协作时常用的模式

- 典型模式
  - Template Method
  - Strategy
  - Observer/Event

### Template Method

- 动机
  - 某项任务有稳定的整体操作结构，但各个子步骤却有很多改变的需求
  - 由于固有的原因，子步骤无法和任务的整体结构同时实现
  - 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求

晚绑定：一个早的东西调用一个晚的东西

模式定义：定义一个操作中的算法的骨架（稳定），而将一些变化延迟（变化）到子类中。Template Method 是的子类可以不改变（复用）一个算法的结构即可重定义（override 重写）该算法某些特定步骤。

前提：一个稳定的算法的骨架

- 要点
  - Template Method 模式是一种非常基础性的设计模式，在面向对象系统中有大量的应用。
  - 它用最简单的机制（虚函数的多态）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构
  - 内涵反向控制结构：不要调用我，让我来调用你
  - 在具体实现方面，被Template Method 调用的虚方法可以有实现，也可以没有任何实现，推荐设置为protected方法

### Strategy

- 动机
  - 软件中某些对象使用的算法多变，使得对象变得异常复杂，并且是性能负担
  - 如何在运行时根据需要透明地更改对象的算法，将算法与对象本身解耦？

遵循开放封闭原则

模式定义：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（拓展，子类化）

- 要点
  - 子类为组件提供了一系列可重用的算法，使得类型在运行时可以方便地根据需要在各个算法之间进行切换
  - 提供了用条件判断语句以外的另一种选择，消除条件判断语句就是在解耦
  - 含有许多条件判断语句的代码通常都需要strategy模式，除非条件判断语句绝对稳定不变
  - 如果strategy对象没有实例变量，那么上下文可以共享同一个strategy对象，从而节省对象开销

### Observer

- 动机
  - 为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生该改变，所有的依赖对象（观察者对象）都将得到通知
  - 如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化
  - 面向对象技术可以将这种依赖关系弱化，形成一种稳定的依赖关系，从而实现软件体系结构的松耦合

C++多继承的最佳实践：主继承类和其他接口（抽象基类）

支持多个：指针列表

模式定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新

- 要点
  - Observer 模式可以独立改变对象和观察者，达到松耦合
  - 发送通知时无需指定观察者，通知会自动传播
  - 观察者自己决定是否需要订阅通知，目标对象对此一无所知
  - Observer 模式是基于事件的UI框架中常用的设计模式，是MVC模式的重要组成部分

## 单一职责模式

- 要点
  - 继承划清职责

- 典型模式
  - Decorator
  - Bridge

### Decorator

- 动机
  - 过度使用继承，继承缺乏灵活性，导致子类的膨胀
  - 如何使对象功能的拓展根据需要在运行时动态地实现，同时避免子类膨胀问题，降低功能拓展变化带来的影响？

用组合替代继承

用父类替代子类

继承来符合接口规范

编译时装配->运行时装配

中间类：Decorator

模式定义：动态（组合）地给一个对象增加一些额外地职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码&减少子类个数）

- 要点
  - 组合替代继承，在运动时动态扩展对象功能地能力，并且可以根据需要扩展多个功能，避免了继承的低灵活性和多子类衍生问题
  - Decorator 类在接口上是继承关系，实现上是组合关系
  - 并非解决多子类衍生的多继承问题，要点在于解决主体类在多个方向上的拓展功能，即是装饰

### Bridge

- 动机
  - 某些类型的固有实现逻辑使得其具有多个变化的维度
  - 如何应对多维度的变化？利用面向对象技术，使类型可以轻松沿着两个乃至多个方向变化，而不引入额外的复杂度

同样的用组合代理继承，将重复的类统一

不同的两种功能被塞到一个类当中，需要被拆分开，一部分继承，一部分组合

模式定义：将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。

- 要点
  - Bridge 使用对象间的组合关系解耦了抽象和实现之间固有的绑定关系，使得其可以沿着各自的维度变化，即对它们进行子类化
  - Bridge 类似于多继承方案，往往违背单一职责原则，复用性较差，Bridge 模式是比多继承方案更好的解决方法
  - Bridge 模式一般在存在两个非常强的变化维度时应用，若一个类也有多个变化维度，此时也可以考虑使用 Bridge 的拓展模式

- 和 Decorator 的区别：并没有继承和组合同一个类，而是两个不同的类来应对两种不同的变化方向

## 对象创建模式

- 要点
  - 绕开 new 创建对象，来避免对象创建过程中导致的紧耦合
  - 支持对象创建的稳定
  - 是接口抽象之后的第一步工作

- 典型模式
  - Factory Method
  - Abstract Factory Method
  - Prototype
  - Builder

### Factory Method

- 动机
  - 需求的变化导致创建对象的具体类型经常变化
  - 通过绕过常规的对象创建方法（new），提供一种封装机制来避免客户程序和具体对象创建工作的紧耦合

接口抽象之后，对象创建时仍然依赖具体类

用方法来返回对象，在 Factory 类当中定义该方法

间接的编译时依赖仍然存在，虚函数可以运行时依赖，变成 Factory 基类和 具体 Factory

Factory 作为成员变量，在初始化时被传入，将依赖赶到局部的某个地方

通过虚函数实现多态 new

模式定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。

- 要点
  - Factory Method 隔离类对象使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系会导致软件的脆弱
  - Factory Method 利用面向对象方法将所要创建的具体对象延迟到子类，从而实现一种扩展（而不是更改）的策略，较好地解决了这种紧耦合关系
  - 解决单个对象的需求变化，缺点在于要求创建方法/参数相同。

### Abstract Factory Method

- 动机
  - 一系列相互依赖的对象的创建工作
  - 通过封装机制避免客户程序和一系列对象创建工作产生紧耦合

抽象类替代具体类，使用 Factory 模式

对象之间存在关联性，将它们放在一个 Factory 类当中实现

模式定义：提供一个接口，让该接口负责创建一系列相关或相互依赖的对象，无需指定它们具体的类。

- 要点
  - 应对多系列对象构建的需求变化
  - 系列对象指特定系列下的对象之间有相互依赖或作用的关系，不同系列对象之间不能相互依赖
  - 主要在于应对新系列的需求变动，但难以应对新对象的需求变动

Factory 模式可以被认为是 Abstract Factory 模式的一个特例

### Prototype

- 动机
  - 创建结构复杂对象，对象本身面临着剧烈的变化，但是却拥有比较稳定一致的接口
  - 向客户对象隔离出易变对象，使依赖易变对象的客户程序不随着需求改变而改变

合并对象基类和工厂基类，使用时通过克隆（拷贝构造函数）来创建对象

原型对象只供克隆，不供使用

模式定义：使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象

- 要点
  - Prototype 模式用于隔离类的使用者与具体类型之间的耦合类型，要求易变类拥有稳定的接口
  - 采用拷贝复制灵活地动态创建新对象
  - 可以利用某些框架中的序列化来实现深拷贝

与 Factory 模式的区别：对象结构复杂，在对象经过配置之后，直接克隆，不需要写一个 Factory 方法中复杂的构造函数

### Builder

- 动机
  - 创建一个复杂对象，各个子部分发生剧烈的变化
  - 但是将它们组合在一起的算法却相对稳定
  - 使用封装机制来隔离出复杂对象各个部分的变化，从而保持系统中的稳定构建算法不随需求改变而改变

与 Template 类似，但 Builder 应对对象的创建工作

构造函数的虚函数是静态绑定，不会调用子类，只能自行定义一个初始化方法

将初始化方法拆分出去，原本的对象作为其成员进行初始化

模式定义：将一个复杂对象的构建与其表示分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）

- 要点
  - Builder 分步骤构建一个复杂的对象，分步骤是稳定的，复杂对象的各个部分则经常变化
  - 主要应对复杂对象各个部分的频繁需求变动，缺点在于难以应对分步骤构建算法的需求变动
  - 要注意不同语言中构造器内调用虚函数的差别

## 对象性能模式

- 要点
  - 面向对象带来的成本

- 典型模式
  - Singleton
  - Flyweight

### Singleton

- 动机
  - 软件系统中，一些特殊的类必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确和效率良好
  - 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例
  - 这应该是类设计者的责任，而不是使用者的责任

设置拷贝构造函数与拷贝构造函数为私有

静态方法与静态变量，线程非安全

加锁，但锁的代价过高

双检查锁，锁前锁后都检查，但由于内存读写 reorder 失效

reorder:编译器优化使得代码与指令执行顺序不同，对象指针被赋值但是没有执行构造器

- 解决
  - volatile 关键字：对象构造过程中不进行 reorder
  - c++11 atomic 内存 fence

模式定义：保证一个类仅有一个实例，并提供一个该实例的全局访问点

- 要点
  - 实例构造器可以设置为 protected 以允许派生
  - 不支持拷贝构造函数与 clone 接口
  - 注意对双检查锁的正确实现

### Flyweight

- 动机
  - 采用纯粹对象方案会导致大量细粒度的对象会很快充斥在系统之，从而带来很高的运行时代价，内存需求
  - 如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？

工厂，对象存在则直接返回对象，对象不存在则创建对象，并将其添加到对象池中

有些语言会在编译过程中进行类似的处理

模式定义：运用共享技术有效地支持大量细粒度的对象

- 要点
  - 解决面向对象的代价问题，一般不触及面向对象的抽象性为你
  - 采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理（只读）
  - 对象数量怎么样算大量需要根据具体应用情况进行评估（对象字段+字节对齐+虚函数表指针）

## 接口隔离模式

- 要点
  - 组件构建过程中，某些接口之间的直接依赖会导致问题
  - 通过添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口

- 典型模式
  - Facade
  - Proxy
  - Adapter
  - Mediator

### Facade

- 动机
  - 组件客户与组件中各种子系统有了过多的耦合
  - 简化外部客户程序和系统间的交互接口，将外部程序的演化和内部子系统的变化之间的依赖相互解耦

系统间耦合的复杂度

模式定义：为子系统中的一组接口提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）

- 要点
  - Facade 模式简化了整个组件系统的接口
  - 内部子系统的任何变化不会影响到 Facade 接口的变化，达到一种解耦的效果
  - Facede 更多是一种架构设计模式
  - Facade 模式中组件内部应该是相互耦合关系比较大的一系列组件，而不是一个简单的功能集合

### Proxy

- 动机
  - 有些对象由于某种原因直接访问会给使用者、或者系统结构带来很多麻烦
  - 如何在不失去透明操作（对对象的操作操作不发生变化）对象的同时来管理和控制这些复杂的对象？增加一层间接层是软件开发中常见的解决方案

模式定义：为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问

客户拿不到 RealSubject，实现 SubjectProxy 对 RealSubject 间接访问

Proxy 有时会用工具来生成

- 要点
  - 增加一层间接曾
  - 具体实现相差非常大，例如 copy-on-write，抽象代理层，在架构层次对对象做 Proxy
  - Proxy 并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时牺牲一些透明性是可以接受的

### Adapter

- 动机
  - 应用环境变化需要将现存对象放到新环境中应用，但是新环境要求的接口是这些现存对象所不满足的
  - 如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？

模式定义：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

继承目标接口，组合遗留接口

例子：STL 的 stack 和 queue 之中的 dequeue

- 要点
  - 主要应用于希望复用一些现存的类但是接口又与复用环境要求不一致的情况，在遗留代码复用、类库迁移等方面非常有用
  - GOF 定义了两种 Adapter 的实现方式：对象适配器和类适配器。但类适配器采用多继承的实现方式，一般不推荐使用。对象适配器采用对象组合的方式，更具有松耦合的特点
  - Adapter 模式的实现非常灵活

### Mediator

- 动机
  - 多个对象互相关联交互，对象之间存在复杂的应用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化
  - 可以使用一个中介对象来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化

组件之间不再相互依赖

模式定义：用一个中间对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显示的相互引用（编译时依赖->运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互

- 要点
  - 将多个对象间复杂的关联关系解耦，Mediator 将多个对象间的控制逻辑进行集中管理，变多个对象互相关联为多个对象和一个中介者关联，简化了系统的维护，抵御了可能的变化
  - 随着控制逻辑的复杂化，Mediator 具体对象的实现可能相当复杂，这时候可以对Mediator对象进行分解处理
  - Facade 解决的是系统外和系统内的隔离（单向），Mediator 解决的是系统内各个组件之间的隔离（双向）

思考：当使用这种模式时，可以将业务逻辑对象分散一些，这样对象内部的业务逻辑负担就不会那么重

## 状态变化模式

- 要点
  - 组件构建过程中，对象状态面临变化
  - 如何对这些变化进行有效的管理，同时又维持高层模块的稳定

- 典型模式
  - State
  - Memento

### State

- 动机
  - 某些对象的状态如果发生改变，其行为也会随之发生变化
  - 如何在运行时根据对象的状态来透明地更改对象的行为，而不会为对象操作和状态转化之间引入紧耦合

模式之间越来越像

Strategy 模式难以应对变化，需要不断修改以应对类型的变化

先提抽象基类，所有状态有关的操作变成状态对象的行为

使用 Singleton 模式

对象作为指针，在行为之后进行更新为下一个对象，自己管理自己的下一个状态

虚函数的本质是运行时的 if else

拓展子类以应对变化

模式定义：允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。

- 要点
  - State 模式将所有与一个特定状态相关的行为都放入一个 State 的子类对象中，在对象状态切换时，切换相应的对象，同时维持 State 的接口，实现了具体操作与状态转换之间的解耦
  - 为不同的状态引入不同的对象使得状态转换变得更加明确，并且可以保证不会出现状态不一起的情况，因为转换是原子性的，要么彻底转换过来，要么不转换
  - 如果 State 对象没有实例变量，那么各个上下文可以共享同一个 State 对象，节省对象开销

### Memento

- 动机
  - 需要某些对象能够回溯到对象之前处于某个点时的状态
  - 如果使用一些公用接口来让其他对象得到对象的状态，便会暴露对象的细节实现
  - 如何在维持封装性的同时实现对象状态的良好保存与恢复

存储方法可能不同

模式定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原本保存的状态。

- 要点
  - Memento 存储 Originator 对象的内部状态，在需要时回复 Originator 状态
  - Memento 模式的核心是信息隐藏，既向外接隐藏信息，保持其封装性，但同时又需要将状态保持到外界
  - 现在往往采用序列化方案来实现 Memento

## 数据结构模式

- 要点
  - 组件内部具有特定的数据结构，客户程序依赖这些特定的数据结构将会极大地破坏组件的复用
  - 将这些特定的数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问
- 典型模式
  - Composite
  - Iterator
  - Chain of Responsibility

### Composite

- 动机
  - 客户代码过多地依赖于对象容器复杂的内部实现结构，对象内部实现接口地变化将引起客户代码的频繁变化
  - 如何将客户代码与复杂的对象容器结构解耦，让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器

两种处理：当前节点和其孩子节点

模式定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）

与 Facade 模式有点像

- 要点
  - 采用树形结构来实现普遍存在的对象容器
  - 将一对多关系转化为一对一关系，使得客户代码可以一致地复用处理对象和对象容器，无需关心处理的是单个对象还是组合的对象容器
  - 将客户代码与复杂的对象容器结构解耦，更能应对变化
  - 具体实现中，可以让父对象中地子对象反向追溯，可以用缓存技巧来改善效率

### Iterator

- 动机
  - 集合对象内部结构常常变化各异，希望在不暴露内部结构的同时，让外部客户代码透明地访问其中包含地元素
  - 这种透明遍历也为同一种算法在多种对象上进行操作提供了可能

在c++当中已经过时了，stl和泛型编程已经实现了迭代器

面向对象的迭代器有缺点：虚函数指针运算成本

stl使用模板实现多态，是编译时多态，运行成本更低

迭代器的接口拥有更多的可能性：往前往后走n 步，多种迭代器

虚函数不支持像 ++ -- 这样的操作

java c# swift 当中使用的仍然是这个，它们不支持编译时多态

模式定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示

- 要点
  - 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示
  - 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作
  - 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

### Chain of Responsibility

- 动机
  - 一个请求可能被多个对象处理，但是每个请求在运行时只能由一个接受者，如果显式指定，将带来请求者与接收者的紧耦合
  - 如何使请求的发送者不需要指定具体的接收者？让请求的接收者自己在运行时来处理请求，从而使两者解耦

例子：UI界面上的点击事件随着层级链条逐层传递

基类当中实现一个多态的链表，请求沿着链表传播，处理或者继续传播

请求的发送稳定，请求的处理变化

模式定义：使多个对象都有机会处理请求，从而避免你请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

- 要点
  - 一个请求可能有多个接受者，但是最后真正的接受者只有一个
  - 将请求的发送者与接收者解耦
  - 对象职责分派更灵活，可以在运行时动态变化
  - 在职责链的末尾应该有一个合理的缺省机制，这是每一个接受对象的职责

## 行为变化模式

- 要点
  - 组件行为变化导致组件本身剧烈的变化，成员函数是编译时绑定，耦合紧密
  - 行为变化模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合
- 典型模式
  - Command
  - Visitor

### Command

- 动机
  - 行为请求者与行为实现者这件存在紧耦合
  - 无法应对对行为进行记录、撤销、事务等变化
  - 将行为请求者与行为实现者解耦，将一组行为抽象为对象，可以实现两者之间的松耦合

对象表征行为，灵活

模式定义：将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作

- 要点
  - 将行为请求者与行为实现者解耦，将行为抽象为对象
  - 具体命令对象有时需要保存一些额外的状态信息，通过使用Composite模式可以将多个命令封装为一个复合命令
  - 与C++中的函数对象有些类似，Command接口规范，更严格，但有性能损失，C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高
    - 函数对象：重载了()操作符的普通类对象

### Visitor

- 动机
  - 需求变化导致某些类层次结构需要添加新的行为，如果直接在基类中做这样的更改，将会给自来带来很繁重的变更负担，甚至破坏原有设计
  - 如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作

前提：能预料到将来会为整个类层次结构添加新的操作

预先设计一个虚函数，调用输入的类特定方法，输入的类中实现具体的方法，输入的类也是多态，可以根据具体类实现多种方法

二次多态辨析

缺点：原本类的数量需要确定，带来脆弱性

模式定义：表示一个作用于某个对象结构中的各个元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作。

- 要点
  - 二次多态辨析实现运行时透明地为类层次结构上地各个类动态添加新的操作
  - 二次多态辨析：第一次为accept方法多态，第二次为Element类多态
  - 缺点在于扩展类层次结构会导致Visitor类的改变。只适用于Element类层次结构稳定，而其中操作却经常面临频繁改动的情况

## 领域规则模式

- 要点
  - 变化频繁，但是可以抽象为规则
  - 结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案
- 典型模式
  - Interpreter

### Interpreter

- 动机
  - 特定领域问题比较复杂，类似结构重复出现
  - 将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子

树形结构表示表达式：变量表达式（子节点）、符号表达式（父节点）都是类型

解析表达式：分析字符串得到语法树，从根节点开始进行计算

模式定义：给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。

- 要点
  - 应用场合：业务规则频繁变换，且类似的结构不断重复出现，并且容易抽象为语法规则，才适合使用interpreter模式
  - 使用面向对象技巧来方便地扩展文法
  - interpreter模式适合比较简单的文法表示，对于复杂的文法表示，interpreter模式会产生比较大的类层次结构，需要求助于语法分析器这样的标准工具

## 总结

- 目标：管理变化，提高复用
- 手段：分解、抽象
- 八大原则：比具体模式更加重要
- 重构技法
  - 静态->动态
  - 早绑定->晚绑定
  - 继承->组合
  - 编译时依赖->运行时依赖
  - 紧耦合->松耦合
- 从封装变化角度对模式分类
- c++对象模型：都时组合指针，而不是继承或组合，可以利用多态的灵活性实现松耦合
- 关注变化点和稳定点：太稳定和太不稳定都不适用设计模式
- 不使用模式的情况：慎重使用设计模式
  - 代码可读性很差时：这是在设计模式之前需要做的工作
  - 需求理解还很浅时
  - 变化没有显现时
  - 不是系统的关键依赖点
  - 项目没有复用价值时
  - 项目将要发布时
- 经验之谈
  - 不要为模式而模式
  - 关注抽象类和接口
  - 理清变化点和稳定点
  - 审视依赖关系
  - 要有Framework和Application的区隔思维：两种身份，逐步上升
  - 良好的设计是演化的结果
- 设计模式成长之路
  - 见模式而不知
  - 作为应用开发人员使用模式
  - 作为框架开发人员为应用设计某些模式
  - 忘掉模式，只有原则

## 参考文献

- 《设计模式：可复用面向对象软件的基础》(GOF)
- 《重构——改善既有代码的设计》
- 《重构与模式》
